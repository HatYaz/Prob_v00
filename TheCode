"""
By Hatem Yazidi 
hatem.yazidi.at.gmail.com

Avis de non-responsabilit√©: 

Les informations, donn√©es et contenus pr√©sent√©s dans ce document sont fournis √† titre informatif uniquement. 
Bien que tous les efforts aient √©t√© d√©ploy√©s pour assurer leur exactitude et leur fiabilit√©, aucune garantie expresse ou implicite n‚Äôest donn√©e quant √† leur exhaustivit√© ou leur actualit√©. 
L‚Äôauteur ne pourra en aucun cas √™tre tenu responsable de toute perte, dommage ou cons√©quence, directe ou indirecte, r√©sultant de l‚Äôutilisation, de l‚Äôinterpr√©tation ou de la diffusion de ces informations.
L‚Äôutilisateur est seul responsable de la v√©rification et de l‚Äôusage qu‚Äôil fait des donn√©es.
"""
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
# from sklearn.metrics import roc_auc_score
import tkinter as tk
from tkinter import filedialog, messagebox, scrolledtext

class RFApp:
    def __init__(self, root):
        self.root = root
        self.root.title("üéØ Pr√©dicteur de Probabilit√©s Random Forest - Copyright 2025, Hatem Yazidi")
        self.root.configure(bg="#2c3e50")  # Fond bleu-gris fonc√©

        # Cadre sup√©rieur pour les boutons
        btn_frame = tk.Frame(root, bg="#34495e", pady=10, padx=10)
        btn_frame.pack(fill='x')

        btn_style = {
            'font': ('Segoe UI', 11, 'bold'),
            'bg': '#1abc9c',
            'fg': 'white',
            'activebackground': '#16a085',
            'activeforeground': 'white',
            'bd': 0,
            'relief': 'flat',
            'cursor': 'hand2',
            'width': 30,
            'pady': 6
        }

        self.load_hist_btn = tk.Button(btn_frame, text="üìÇ Charger donn√©es historiques", command=self.load_historical, **btn_style)
        self.load_hist_btn.grid(row=0, column=0, padx=8)

        self.train_btn = tk.Button(btn_frame, text="‚öôÔ∏è Entra√Æner le mod√®le", command=self.train_model, state='disabled', **btn_style)
        self.train_btn.grid(row=0, column=1, padx=8)

        self.load_new_btn = tk.Button(
        btn_frame,
        text="üìä Charger nouvelles donn√©es\n& Pr√©dire",
        command=self.load_and_predict,
        state='disabled',
        **btn_style
    )
        self.load_new_btn.grid(row=0, column=2, padx=8)

        self.save_btn = tk.Button(btn_frame, text="üíæ Enregistrer pr√©dictions", command=self.save_predictions, state='disabled', **btn_style)
        self.save_btn.grid(row=0, column=3, padx=8)

        self.exit_btn = tk.Button(btn_frame, text="‚ùå Quitter", command=self.root.quit, bg='#e74c3c', fg='white',
                                  activebackground='#c0392b', activeforeground='white',
                                  font=('Segoe UI', 11, 'bold'), bd=0, relief='flat', cursor='hand2', width=10, pady=6)
        self.exit_btn.grid(row=0, column=4, padx=8)

        # Label pour messages d'√©tat
        self.status_label = tk.Label(root, text="Veuillez charger un fichier Excel de donn√©es historiques pour commencer.",
                                     bg="#2c3e50", fg="white", font=('Segoe UI', 12, 'italic'))
        self.status_label.pack(pady=(10, 0))

        # Cadre pour la zone de texte des r√©sultats
        results_frame = tk.Frame(root, bg="#34495e", padx=10, pady=10)
        results_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Zone de texte pour r√©sultats
        self.results_text = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 11),
                                                    bg="#ecf0f1", fg="#2c3e50", state='normal')
        self.results_text.pack(fill='both', expand=True)

        # Instructions initiales dans la zone de texte
        instructions = (
            "üìå Instructions d'utilisation :\n"
            " ====== Salut, Jean-Denis, Etienne et Jonathan ========\n"
            "\n"
            "1Ô∏è‚É£ Cliquez sur ¬´ üìÇ Charger donn√©es historiques ¬ª et s√©lectionnez un fichier Excel contenant les colonnes Var1 √† Var10 et Target.\n"
            "2Ô∏è‚É£ Cliquez sur ¬´ ‚öôÔ∏è Entra√Æner le mod√®le ¬ª pour construire l‚Äôalgorithme.\n"
            "3Ô∏è‚É£ Cliquez sur ¬´ üìä Charger nouvelles donn√©es & Pr√©dire ¬ª pour pr√©dire les probabilit√©s.\n"
            "4Ô∏è‚É£ Les r√©sultats s‚Äôafficheront ici avec la date et la probabilit√© (%) que Target d√©passe le seuil m√©dian.\n"
            "5Ô∏è‚É£ Cliquez sur ¬´ üíæ Enregistrer pr√©dictions ¬ª pour sauvegarder les r√©sultats au format Excel.\n\n"
            "‚ÑπÔ∏è Astuce : Utilisez des fichiers Excel bien format√©s pour √©viter les erreurs."
        )

        self.results_text.insert(tk.END, instructions)
        self.results_text.config(state='disabled')  # on verrouille la zone

        # self.results_text = scrolledtext.ScrolledText(results_frame, wrap=tk.WORD, font=('Consolas', 11),
                                                    #   bg="#ecf0f1", fg="#2c3e50", state='disabled')
        # self.results_text.pack(fill='both', expand=True)

        # Variables pour les donn√©es et le mod√®le
        self.df_hist = None
        self.model = None
        self.seuil = None
        self.df_new = None

    def update_status(self, msg):
        self.status_label.config(text=msg)

    def load_historical(self):
        file_path = filedialog.askopenfilename(title="S√©lectionner le fichier Excel historique",
                                               filetypes=[("Fichiers Excel", "*.xlsx;*.xls")])
        if not file_path:
            return
        try:
            self.df_hist = pd.read_excel(file_path)
            required_cols = ['Var1','Var2','Var3','Var4','Var5','Var6','Var7','Var8','Var9','Var10','Target']
            if not all(col in self.df_hist.columns for col in required_cols):
                messagebox.showerror("Erreur", f"Le fichier doit contenir les colonnes : {', '.join(required_cols)}")
                self.df_hist = None
                self.update_status("√âchec du chargement des donn√©es historiques.")
                return
            self.update_status(f"Donn√©es historiques charg√©es avec {len(self.df_hist)} lignes.")
            self.train_btn.config(state='normal')
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de charger le fichier :\n{e}")
            self.update_status("√âchec du chargement des donn√©es historiques.")

    def train_model(self):
        if self.df_hist is None:
            messagebox.showerror("Erreur", "Veuillez d'abord charger des donn√©es historiques.")
            return

        self.seuil = self.df_hist['Target'].median()
        self.df_hist['Target_bin'] = (self.df_hist['Target'] > self.seuil).astype(int)

        features = ['Var1','Var2','Var3','Var4','Var5','Var6','Var7','Var8','Var9','Var10']
        X = self.df_hist[features]
        y = self.df_hist['Target_bin']

        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        self.model = RandomForestClassifier(n_estimators=100, random_state=42)
        self.model.fit(X_train, y_train)

        y_proba = self.model.predict_proba(X_test)[:,1]
        # auc = roc_auc_score(y_test, y_proba)

        # messagebox.showinfo("Entra√Ænement termin√©", f"Mod√®le entra√Æn√©.\nROC AUC sur jeu de test : {auc:.3f}")
        # self.update_status(f"Mod√®le entra√Æn√©. ROC AUC : {auc:.3f}")

        self.load_new_btn.config(state='normal')

    def load_and_predict(self):
        if self.model is None:
            messagebox.showerror("Erreur", "Veuillez d'abord entra√Æner le mod√®le.")
            return

        file_path = filedialog.askopenfilename(title="S√©lectionner le nouveau fichier Excel",
                                               filetypes=[("Fichiers Excel", "*.xlsx;*.xls")])
        if not file_path:
            return

        try:
            self.df_new = pd.read_excel(file_path)
            features = ['Var1','Var2','Var3','Var4','Var5','Var6','Var7','Var8','Var9','Var10']
            if not all(col in self.df_new.columns for col in features):
                messagebox.showerror("Erreur", f"Le fichier doit contenir les colonnes : {', '.join(features)}")
                self.df_new = None
                self.update_status("√âchec du chargement des nouvelles donn√©es.")
                return

            probs = self.model.predict_proba(self.df_new[features])[:,1]
            self.df_new['Probabilit√©_Target_sup_Seuil'] = probs

            self.display_results_text()

            self.save_btn.config(state='normal')
            self.update_status(f"Pr√©dictions termin√©es pour {len(self.df_new)} lignes.")
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de charger ou pr√©dire :\n{e}")
            self.update_status("√âchec des pr√©dictions.")

    def display_results_text(self):
        self.results_text.config(state='normal')
        self.results_text.delete(1.0, tk.END)
        self.results_text.insert(tk.END, f"{'Index':<8}{'Date':<20}{'Probabilit√© (%)':>15}\n")
        self.results_text.insert(tk.END, "-"*45 + "\n")
        for idx, (date, prob) in enumerate(zip(self.df_new['Date'], self.df_new['Probabilit√©_Target_sup_Seuil'])):
            date_str = str(date)[:19]
            prob_pct = prob * 100
            self.results_text.insert(tk.END, f"{idx:<8}{date_str:<20}{prob_pct:>14.2f}%\n")
        self.results_text.config(state='disabled')

    def save_predictions(self):
        if self.df_new is None or 'Probabilit√©_Target_sup_Seuil' not in self.df_new.columns:
            messagebox.showerror("Erreur", "Aucune pr√©diction √† enregistrer.")
            return
        save_path = filedialog.asksaveasfilename(defaultextension=".xlsx",
                                                 filetypes=[("Fichiers Excel", "*.xlsx;*.xls")],
                                                 title="Enregistrer les pr√©dictions sous...")
        if not save_path:
            return
        try:
            self.df_new.to_excel(save_path, index=False)
            messagebox.showinfo("Enregistr√©", f"Pr√©dictions enregistr√©es dans :\n{save_path}")
            self.update_status(f"Pr√©dictions enregistr√©es dans {save_path}")
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible d'enregistrer le fichier :\n{e}")
            self.update_status("√âchec de l'enregistrement.")

if __name__ == "__main__":
    root = tk.Tk()
    root.geometry("1500x650")
    app = RFApp(root)
    root.mainloop()
